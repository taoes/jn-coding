---
title: 秒杀系统的架构设计
date: 2021-11-21 17:49:40
tags:
author: 枕上江南
urlName: second_kill_system
---

库存只有一份，所有人会在集中的时间读和写这些数据。 例如小米手机每周二的秒杀，可能手机只有1万部，但瞬时进入的流量可能是几百几千万。 又例如12306抢票，亦与秒杀类似，瞬时流量更甚。瞬时流量太高，造成大量的锁表，系统的性能瓶颈 等因素导致系统无法在短时间内提供相应，甚至出现系统崩溃的可能，所以一个优秀的秒杀系统，虽然现在看着烂大街，但是细细琢磨，这其中的营养往往非常丰富！

<!--more-->
## 1、什么是秒杀系统
常见的单点系统架构如下图：<br />
![image.png](https://pic.zhoutao123.com/miaoshao-1.png)
<br />在一些运营需求的情况下，从浏览器大量的请求，会落到数据库层，造成服务的请求缓慢，甚至整个应用的不可用，我们就逐渐改造上面的单点服务系统，达到秒杀系统的基本需求。<br />
<br />秒杀场景一般会在电商网站举行一些活动或者节假日在12306网站上抢票时遇到。对于电商网站中一些稀缺或者特价商品，电商网站一般会在约定时间点对其进行限量销售，因为这些商品的特殊性，会吸引大量用户前来抢购，并且会在约定的时间点同时在秒杀页面进行抢购。
<a name="7RicR"></a>
### 1.1 秒杀系统场景特点
<br />

- [x]  秒杀时大量用户会在同一时间同时进行抢购，网站瞬时访问流量激增。
- [x]  秒杀一般是访问请求数量远远大于库存数量，只有少部分用户能够秒杀成功。
- [x]  秒杀业务流程比较简单，一般就是下订单减库存。


<br />
<br />

<a name="dhgZ4"></a>
## 2、系统优化原则


<a name="A2Ooa"></a>
### 2.1 将请求拦截到系统上游
在秒杀系统中，把部分请求都是无效的，直接把请求落在数据库或者应用层是不合理的，应道遵循 在浏览器层首先拦截的，比如根据时间判断是否到达秒杀时间,禁止用户多次提交等。每次刷新均在浏览器做页面缓存，防止因页面在不停地刷新导致的请求过多的问题。<br />但是这种方式是无法处理一些脚本秒杀，因此在秒杀系统中如何对用户鉴定也是非常重要的一步。这种方式可以通过uid的方式判定，同一个uid在一段时间内只能请求一次，多次请求使用缓存的方式展示或者使用限流的方式提供。<br />

<a name="hfAgm"></a>
### 2.2 在瞬时流量过高的情况下，考虑异步处理
在秒杀开始的短时间内，大量请求过来，单薄的单点系统一般无法承受住，所以这个时候可以将请求存放到MQ中，在接收到请求之后，由系统慢慢处理，客户端为了展示效果，可以使用将长时间间隔的轮询的方式，查询是否秒杀成功。<br />比如秒杀系统中由1000台手机，我们就没有必要接收10W个请求了，只要接收1000个请求即可，其他的均是秒杀失败的请求。<br />

<a name="tqHui"></a>
### 2.3、尽量使用缓存，降低数据库的访问量
用户发送异步请求后，等待轮询查询秒杀结果的请求中，我们就可以使用缓存的方式来实现，这里就需要为每个缓存设置不同的有效期，防止缓存雪崩。<br />浏览器页面刷新的数据也可以将商品的数据保存在localstore 中，使用缓存减少请求，降低服务器的压力。<br />
<br />

<a name="lkZxJ"></a>
## 3、设计原则

- [x]  保证系统可用，不因为高并发访问崩溃
- [x]  及时做系统的压力测试


<br />

<a name="6K3hf"></a>
## 4、各层优化方向

<br />
<br />下面展示了在常规单点应用的秒杀系统优化的部分，可以看到每个访问层句可以进行不同方案的优化。其中我们的主要目标是拦截掉大量的无用的请求，将有效的请求落入到数据库层上，减少下层组件的压力。

![image.png](https://pic.zhoutao123.com/miaoshao-2.png)
<br />

<a name="1GZA3"></a>
### 1、客户端优化

<br />防止客户多次提交，丢弃到短时间内的大量无效请求, 比如请求未完成之前不允许下次提交，可以将提交按钮置灰，在业务逻辑层面，可以尝试在10S之内只能提交一次等等手段，来在客户端避免多次提交。这种方式防君子不防小人，一些人采用抓包或者模拟请求的方式来进行操作，就无法进行有效的过滤了。<br />

<a name="aK5Nc"></a>
### 2、站点层拦截
这里的站点层只要指的是Nginx等网络层，这一次可以通过限流或者缓存的方式实现。比如在10S之后限制某个UID只能请求一次，可以防止黑客恶意请求提交，这种方式有可能会过滤正常的用户，造成误伤。其次可以在10S之后某个UID的请求均返回同一个结果，将此结果缓存系统中，10S之内的请求均使用该缓存。在站点层做拦截，可以大幅度的降低服务器的负载，排除大量的无用的数据提交。<br />

<a name="jtie4"></a>
### 3、服务层处理
在服务层优化，可以有限的透过N个请求，比如商品只有100个，站顶层透过1W的请求也是没用的，其中的99%都是无用的请求，因此，在服务层限制请求的数目，在接到100个有效的请求之后，其余的返回失败，或者可以将1W个请求透传过来，这样可以放在请求队列或者消息队列中，慢慢处理数据。这种方式也可以拦截大量无用的请求。<br />

<a name="5uqZX"></a>
### 4、数据库层

<br />在前面3层的优化下，已经有很少的请求落到数据库层上了，但是从技术的角度，我们也要有一些方案能够实现数据库的优化。常见的方案就是一主多从或者多主多从以及分库分表(这是另外一篇文章的重点内容，这里不做过多的阐述)。<br />
<br />
<br />

